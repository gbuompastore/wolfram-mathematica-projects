(* ::Package:: *)

(* ::Input:: *)
(*(* Author: Giuliano Buompastore *)
(*Implementazione dell'algoritmo di cifratura speck per tutti i testi vector del progetto *) *)
(*(*Definizione delle funzioni di rotazione sinistra e destra*)*)
(*ror[x_,p_]:=BitAnd[ BitOr[BitShiftRight[x,p] ,   BitShiftLeft[x,n-p]  ],mask]*)
(*rol[x_,p_]:=BitAnd[BitOr[BitShiftLeft[x,p] ,   BitShiftRight[x,n-p]  ],mask]*)
(**)
(**)


(* ::Input:: *)
(*(* Funzione per la generazione del key scheduling *)*)
(*expandKey[k_]:=Module[{key,l,y,len},key=ConstantArray[0,rounds+2];*)
(*l=ConstantArray[0,rounds+2];*)
(*len=Length[k];*)
(*       *)
(*For[i=1,i<=len,i++,If[i==1,key[[1]]=k[[len]],l[[i-1]]=k[[len-i+1]]]]*)
(**)
(*For[i=1,i<rounds,i++,*)
(*l[[i]]=BitAnd[ BitXor[ror[l[[i]],alpha]+key[[i]],i-1],mask];*)
(*	 y=BitAnd[BitXor[rol[key[[i]],beta],l[[i]]],mask];*)
(*	l[[i+m-1 ]]=l[[i]];*)
(*	key[[i+1]]=y;*)
(*];*)
(*	key*)
(*];*)
(*expandKey[key]*)


(* ::Input:: *)
(**)


(* ::Input:: *)
(*(* Funzione di encrypt*)*)
(*encrypt[pt_,k_]:=Module[{x,y,keyschedule,a,b},keyschedule=expandKey[k];*)
(*y=pt[[2]];*)
(*x=pt[[1]];*)
(*For[i=1,i<=rounds  ,i++,*)
(*x=BitAnd[BitXor[ror[x,alpha]+y,keyschedule[[i]]],mask];*)
(*y= BitAnd[BitXor[rol[y,beta],x],mask];*)
(*	];*)
(*{x,y}*)
(*];*)
(**)


(* ::Input:: *)
(*(* funzione di decrypt*)*)


(* ::Input:: *)
(*decrypt[pt_,k_]:=Module[{x,y,keyschedule,a,b},keyschedule=expandKey[k];*)
(*y=pt[[2]];*)
(*x=pt[[1]];*)
(*For[i=rounds,i>=1  ,i--,*)
(*y= BitAnd[ror[BitXor[x,y],beta],mask];*)
(*x= BitAnd[BitXor[x,keyschedule[[i]]]-y,mask];*)
(*x= rol[x,alpha];*)
(*	];*)
(*{x,y}*)
(*];*)


(* ::Input:: *)
(*(*  *)
(*Speck 32/64*)*)
(**)
(*n=16;  (* word size*)*)
(*m = 4  ;(* key words*)*)
(*mask= 2^n-1 ;*)
(**)
(*rounds=22; (*Numero di round dell'algoritmo*)*)
(*alpha=7;*)
(*beta=2 ;*)
(*key={16^^1918,16^^1110,16^^908,16^^100} (* Chiave in formato Esadecimale*)*)
(*plaintext ={16^^6574,16^^694c} (* Testo di riferimento in Esadecimale*)*)
(*v=encrypt[plaintext,key]*)
(*Map[IntegerString[#,16]&,v] *)
(**)
(*dec=decrypt[v,key]*)
(*Map[IntegerString[#,16]&,dec] *)


(* ::Input:: *)
(*(*Speck 48/72 *)*)
(*n=24;  (* word size*)*)
(*m = 3; (* key words*)*)
(*mask= 2^n-1;*)
(*rounds=22 ;*)
(*alpha=8;*)
(*beta=3;*)
(*key={16^^121110,16^^0a0908,16^^020100} *)
(*plaintext ={16^^20796c,16^^6c6172} (* Testo di riferimento in Esadecimale*)*)
(*v=encrypt[plaintext,key];*)
(*Map[IntegerString[#,16]&,v]*)
(**)
(*dec=decrypt[v,key];*)
(*Map[IntegerString[#,16]&,dec]*)


(* ::Input:: *)
(*(*Speck 48/96 *)*)
(*n=24;  (* word size*)*)
(*m = 4 ;(* key words*)*)
(*mask= 2^n-1;*)
(*rounds=23;*)
(*alpha=8;*)
(*beta=3;*)
(*key={16^^1a1918,16^^121110,16^^0a0908,16^^020100} *)
(*plaintext ={16^^6d2073,16^^696874} (* Testo di riferimento in Esadecimale*)*)
(*v=encrypt[plaintext,key];*)
(*Map[IntegerString[#,16]&,v]*)
(**)
(*dec=decrypt[v,key];*)
(*Map[IntegerString[#,16]&,dec]*)


(* ::Input:: *)
(*(*dec=Map[IntegerString[#,16]&,decrypt[v,key]]*)*)


(* ::Input:: *)
(*(*Speck 64/96 *)*)
(*n=32  ;(* word size*)*)
(*m = 3 ;(* key words*)*)
(*mask= 2^n-1;*)
(*rounds=26;*)
(*alpha=8;*)
(*beta=3;*)
(*key={16^^13121110,16^^0b0a0908,16^^03020100} *)
(*plaintext ={16^^74614620,16^^736e6165} (* Testo di riferimento in Esadecimale*)*)
(*v=encrypt[plaintext,key];*)
(*Map[IntegerString[#,16]&,v]*)
(**)
(*dec=decrypt[v,key];*)
(*Map[IntegerString[#,16]&,dec]*)
(**)


(* ::Input:: *)
(*(*Speck 64/128 *)*)
(*n=32 ; (* word size*)*)
(*m = 4 ;(* key words*)*)
(*mask= 2^n-1;*)
(*rounds=27;*)
(*alpha=8;*)
(*beta=3;*)
(*key={16^^1b1a1918,16^^13121110,16^^0b0a0908,16^^03020100} *)
(*plaintext ={16^^3b726574,16^^7475432d} (* Testo di riferimento in Esadecimale*)*)
(*v=encrypt[plaintext,key];*)
(*Map[IntegerString[#,16]&,v]*)
(**)
(*dec=decrypt[v,key];*)
(*Map[IntegerString[#,16]&,dec]*)
(**)


(* ::Input:: *)
(*(*Speck 96/96 *)*)
(*n=48 ; (* word size*)*)
(*m = 2 ;(* key words*)*)
(*mask= 2^n-1;*)
(*rounds=28;*)
(*alpha=8;*)
(*beta=3;*)
(*key={16^^0d0c0b0a0908,16^^050403020100} *)
(*plaintext ={16^^65776f68202c,16^^656761737520} (* Testo di riferimento in Esadecimale*)*)
(*v=encrypt[plaintext,key];*)
(*Map[IntegerString[#,16]&,v]*)
(**)
(*dec=decrypt[v,key];*)
(*Map[IntegerString[#,16]&,dec]*)


(* ::Input:: *)
(*(*Speck 96/144 *)*)
(*n=48 ; (* word size*)*)
(*m = 3 ;(* key words*)*)
(*mask= 2^n-1;*)
(*rounds=29;*)
(*alpha=8;*)
(*beta=3;*)
(*key={16^^151413121110,16^^0d0c0b0a0908,16^^050403020100} *)
(*plaintext ={16^^656d6974206e,16^^69202c726576} (* Testo di riferimento in Esadecimale*)*)
(*v=encrypt[plaintext,key];*)
(*Map[IntegerString[#,16]&,v]*)
(**)
(*dec=decrypt[v,key];*)
(*Map[IntegerString[#,16]&,dec]*)


(* ::Input:: *)
(*(*Speck 128/128 *)*)
(*n=64 ; (* word size*)*)
(*m = 2;(* key words*)*)
(*mask= 2^n-1;*)
(*rounds=32;*)
(*alpha=8;*)
(*beta=3;*)
(*key={16^^0f0e0d0c0b0a0908,16^^0706050403020100} *)
(*plaintext ={16^^6c61766975716520,16^^7469206564616d20} (* Testo di riferimento in Esadecimale*)*)
(*v=encrypt[plaintext,key];*)
(*Map[IntegerString[#,16]&,v]*)
(**)
(*dec=decrypt[v,key];*)
(*Map[IntegerString[#,16]&,dec]*)


(* ::Input:: *)
(*{}*)


(* ::Input:: *)
(*(*Speck 128/192 *)*)
(*n=64 ; (* word size*)*)
(*m = 3;(* key words*)*)
(*mask= 2^n-1;*)
(*rounds=33;*)
(*alpha=8;*)
(*beta=3;*)
(*key={16^^1716151413121110,16^^0f0e0d0c0b0a0908,16^^0706050403020100} *)
(*plaintext ={16^^7261482066656968,16^^43206f7420746e65} (* Testo di riferimento in Esadecimale*)*)
(*v=encrypt[plaintext,key];*)
(*Map[IntegerString[#,16]&,v]*)
(**)
(*dec=decrypt[v,key];*)
(*Map[IntegerString[#,16]&,dec]*)


(* ::Input:: *)
(*(*Speck 128/256 *)*)


(* ::Input:: *)
(*n=64 ; (* word size*)*)
(*m = 4;(* key words*)*)
(*mask= 2^n-1;*)
(*rounds=34;*)
(*alpha=8;*)
(*beta=3;*)
(*key={16^^1f1e1d1c1b1a1918,16^^1716151413121110,16^^0f0e0d0c0b0a0908,16^^0706050403020100} *)
(*plaintext ={16^^65736f6874206e49,16^^202e72656e6f6f70} (* Testo di riferimento in Esadecimale*)*)
(*v=encrypt[plaintext,key];*)
(*Map[IntegerString[#,16]&,v]*)
(**)
(*dec=decrypt[v,key];*)
(*Map[IntegerString[#,16]&,dec]*)
